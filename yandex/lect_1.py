# Сложность, особые случаи и тестирование алгоритмов

# Сложность - это порядок количества действий, которые выполняет алгоритм

# Пространственная сложность - количество потребляемой памяти


# Задача 1

"""
Дана строка в кодировке UTF-8. Найти самый часто встречающийся в ней символ.
Если несколько символов встречаются одинаковое количество раз, то вывести любой
"""
# стандартная задача на поиск максимума, решение за О(N^2)

s = input()
ans = '' # создаем строку для хранения символа
anscount = 0 # конечный счетчик

for i in range(len(s)): # берем каждую букву в строке и считаем ее
    nowcnt = 0 # временный счетчик
    for j in range(len(s)): # итерируемся и сравниваем сколько раз эта буква была в строке
        if s[i] == s[j]: # считаем буквы
            nowcnt += 1
    if nowcnt > anscount: # если результат конечного счетчика меньше временного, то меняем символ и результат
        ans = s[i]
        anscount = nowcnt
print(ans)


# решение за O(Nk)
# вместо перебора всей строки, создаем множество символов, и больше не перебираем символы повторно

s = input()
ans = ''  # создаем строку для хранения символа
anscount = 0  # конечный счетчик

for i in range(len(set(s))):  # берем каждую букву в строке и считаем ее
    nowcnt = 0  # временный счетчик
    for j in range(len(s)):  # итерируемся и сравниваем сколько раз эта буква была в строке
        if s[i] == s[j]:  # считаем буквы
            nowcnt += 1
    if nowcnt > anscount:  # если результат конечного счетчика меньше временного, то меняем символ и результат
        ans = s[i]
        anscount = nowcnt
print(ans)


# 3 способ использование словаря для подсчета, сложность N + K == N

s = input()
dct = {}
anscount = 0
ans = ""

for now in s:
    if now not in dct:
        dct[now] = 0
    dct[now] += 1

for key in dct:
    if dct[key] > anscount:
        anscount = dct[key]
        ans = key



        # Особые случаи
"""
Отстуствует ans="", это может привести к тому, что если на вход подается пустая строка,то в цикл
мы не попадем
"""

s = input()
dct = {}
anscount = 0

for now in s:
    if now not in dct:
        dct[now] = 0
    dct[now] += 1

for key in dct:
    if dct[key] > anscount:
        anscount = dct[key]
        ans = key

# Задача 2

"""
Идея, берем нулевой элемент последовательности и к нему прибавляем остальные.
Недостаток в if, ненужная проверка
"""
seq = [1,2,3,4,5]

if len(seq) == 0:
    print(0)

else:
    seqsum = seq[0]
    for i in range(1, len(seq)):
        seqsum += seq[i]
    print(seqsum)

# исправленный вариант

seq = [1, 2, 3, 4, 5]

seqsum = 0
for i in range(len(seq)):
    seqsum += seq[i]
print(seqsum)


# задача 3

"""
Максимум последовательности.
Это решение будет работать до тех пор пока все числа неотрицательные


"""
seq = [1, 2, 3, 4, 5]

seqsum = 0
for i in range(len(seq)):
    if seq[i] > seqsum:
        seqsum = seq[i]
print(seqsum)

# Решение - сравнивать относительно первого элемента

seq = [1, 2, 3, 4, 5]

if len(seq) == 0:
    print("-inf")
else:
    seqsum = seq[0]
    for i in range(1, len(seq)):
        if seq[i] > seqsum:
            seqsum = seq[i]
    print(seqsum)



        # Тестирование

"""
1. Общий случай
2. Случай по краям
3. Все элементы одинаковые
4. Один элемент
5. Пустая последовательность
6. Все отрицательные числа


"""
